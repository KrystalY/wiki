(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{546:function(t,e,r){"use strict";r.r(e);var a=r(41),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"testing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#testing"}},[t._v("#")]),t._v(" Testing")]),t._v(" "),r("h2",{attrs:{id:"소프트웨어-관점에서-테스트를-정의"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#소프트웨어-관점에서-테스트를-정의"}},[t._v("#")]),t._v(" "),r("strong",[t._v("소프트웨어 관점에서 테스트를 정의")])]),t._v(" "),r("p",[t._v('"애플리케이션이 요구 사항에 맞게 동작하는지를 검증하는 행위"')]),t._v(" "),r("p",[t._v("보통은 개발의 결과물이 최종적으로 사용자에게 전달되기 직전에 QA라는 과정을 거치는데, 이과정을 테스트라고 보는 것이 일반적\n하지만 실제로 전체 개발 과정을 살펴보면 이러한 검증이 각 단계에서 꾸준히 이뤄지는 것을 확인\n예1) 프로토타입 과정에서 UX를 미리 검증하고 개선하는 일\n예2) 서버의 API를 호출하고 기대값을 확인하는 일\n예3) 마크업이 끝난 이후에 디자인 시안과 비교해보는 일")]),t._v(" "),r("h2",{attrs:{id:"자동화-테스트의-중요성"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#자동화-테스트의-중요성"}},[t._v("#")]),t._v(" 자동화 테스트의 중요성")]),t._v(" "),r("blockquote",[r("p",[t._v("테스트는 대부분 반복 작업 -> 테스트 비용 증가 -> 코드 개선 망설임 증가 -> 코드 품질 저하")])]),t._v(" "),r("h2",{attrs:{id:"테스트의-기회비용"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#테스트의-기회비용"}},[t._v("#")]),t._v(" 테스트의 기회비용")]),t._v(" "),r("ul",[r("li",[t._v("단순한 코드에는 테스트 하지말자(가성비가 좋은 곳에만)")]),t._v(" "),r("li",[t._v("기존에 작성되어 있는 테스트라도 불필요하면 제거하자")]),t._v(" "),r("li",[t._v("TDD의 창시자인 켄트 백(Stack Overflow 답변 중)\n"),r("blockquote",[r("p",[t._v('...나는 테스트 코드가 아니라 제대로 작동하는 제품 코드에 대한 보수를 받는다. 그러므로 나의 원칙은 "특정 수준의 신뢰를 보장하는 최소한의 테스트 코드만 작성한다"이다...(중략)... 딱히 실수를 범할 것 같지 않은 코드는 테스트하지 않는다.')])])]),t._v(" "),r("li",[t._v("Extreme Programming Explained 책 내용 중\n"),r("blockquote",[r("p",[t._v("...완벽하게 모든 것을 다 테스트하려고 하면, 테스트 코드는 필연적으로 오류가 발생하기 쉬운 복잡한 코드가 된다...(중략)... 만약 코드가 너무 간단해서 오류가 날 확률이 거의 없다면, 테스트를 하지 않는 편이 낫다.")])])])]),t._v(" "),r("h2",{attrs:{id:"좋은-테스트의-조건"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#좋은-테스트의-조건"}},[t._v("#")]),t._v(" 좋은 테스트의 조건")]),t._v(" "),r("blockquote",[r("p",[t._v("애플리케이션의 성격, 개발 도구 및 언어, 사용자 환경 등 다양한 요인에 의해 영향을 받는다")])]),t._v(" "),r("ul",[r("li",[t._v("실행 속도가 빨라야 한다.")]),t._v(" "),r("li",[t._v("내부 구현 변경 시 깨지지 않아야 한다.")]),t._v(" "),r("li",[t._v("버그를 검출할 수 있어야 한다.(*테스트 명세는 구체적이어야 하며, 모의 객체의 사용은 최대한 지양)")]),t._v(" "),r("li",[t._v("테스트의 결과가 안정적이어야 한다.(외부 환경의 영향을 최소화해서 언제 어디서 실행해도 동일한 결과 보장: 현재 시간, 현재 기기의 OS, 네트워크 상태 등)")]),t._v(" "),r("li",[t._v('의도가 명확하게 들어나야 한다.(기계가 읽기 좋은 코드가 아닌 "사람이 읽기 좋은" 코드)')])]),t._v(" "),r("h4",{attrs:{id:"references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[t._v("#")]),t._v(" References")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://meetup.toast.com/posts/174",target:"_blank",rel:"noopener noreferrer"}},[t._v("실용적인 프론트엔드 테스트 전략 (1)"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://meetup.toast.com/posts/246",target:"_blank",rel:"noopener noreferrer"}},[t._v("유용한 테스트 케이스를 위한 개발자의 자세"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://meetup.toast.com/posts/242",target:"_blank",rel:"noopener noreferrer"}},[t._v("라이트하우스 6.0에서 바뀐 성능 지표변화"),r("OutboundLink")],1)])]),t._v(" "),r("h4",{attrs:{id:"see-also"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#see-also"}},[t._v("#")]),t._v(" See Also")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://meetup.toast.com/posts/220",target:"_blank",rel:"noopener noreferrer"}},[t._v("트리 쉐이킹 되는 UI 라이브러리 만들기 ㄱ부터 ㅎ까지"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);