# Debug it! 실용주의 디버깅

> 소프트웨어 개발자가 꼭 알아야 할 디버깅의 정석
>
> 폴 부처 지음 / 박 일 옮김

### 문제의 핵심 > 구조적 접근 (page 28.)

#### **실천하기**

다음은 꼭 지키자.

- 소프트웨어가 왜 이상하게 작동되는지 알기
- 문제를 고치기
- 다른 부분을 깨뜨리지 않기
- 전반적인 품질 유지나 향상시키기
- 같은 문제가 다른곳에도 있는지 확인하고 재발을 막기
  - 소프트웨어를 잘 활용해 어떤 일이 벌어지는지를 보여주자.
  - 한 번에 한 문제만 해결하자.
  - 무엇을 찾고 있는지를 정확하게 알자.
- 어떤일이 벌어지고 있는가?
- 어떻게 실행돼야 하는가?
  간단한 것부터 먼저 살피자.

### 문제의 핵심 > 재현 (page 60.)

#### **실천하기**

- 무엇보다도 먼저 재현 방법을 찾자.
- 버그가 발견된 버전의 소프트웨어를 실행하자.
- 재현하려는 환경을 버그가 발견된 환경과 똑같이 만들자.
- 버그 재현에 꼭 필요한 입력을 다음 방법을 통해 찾자.
  - 추론
  - 로그로 의심 가는 입력을 기록
  - 재현 방법을 반복해서 다듬어 신뢰할 수 있고 편리하게 만들자.
  - 재현 단계, 데이터 크기, 시간을 줄인다.
  - 비결정성 제거
  - 자동화

### 문제의 핵심 > 진단 (page 89.)

#### **인내**

그렇게 보이지 않을 때도 있겠지만 사실 진단할 수 없는 버그는 없다. 컴퓨터에서 실행되는 모든 소프트웨어는 사람이 작성한 것이고, 이런 소프트웨어에서 어떤 작업을 하는지 정확하게 알 수 있으므로 언제든지 충분한 정보를 얻을 수 있다. 이런 점에서 소프트웨어는 인간 세상의 다른 분야와는 참 다르다.

물론 진단이 쉽다는 건 아니다. 하지만 지금 보고 있는 문제 때문에 좌절하더라도 언제나 길은 있다는 점을 잊지 말자. 충분한 시간과 노력, 각오만 있다면 언젠가는 해답을 찾을 것이다.

#### **실천하기**

- 가설을 세운후 실험으로 확인한다.
  - 실험으로 무엇을 알고 싶은지 분명히 안다.
  - 한 번에 하나만 수정한다.
  - 지금까지 시도해 본 것들을 기록한다.
  - 아무것도 무시하지 않는다.
- 제대로 되지 않는다면
  - 수정해도 효과가 없는 것 같다면 원했던 부분을 고친 게 아니다.
  - 가정을 확인한다.
  - 원인이 여러 개인 것은 아닌지? 내부 시스템을 변경하는 것은 아닌지?
- 진단을 확인한다.

### 문제의 핵심 > 수정

#### **리팩토링의 핵심 통찰은 무엇인가요? (page 99.)**

...
리팩토링에는 단순히 유용한 기법을 분류한 것 이상의 것이 있다. ...

- 광범위한 단위 테스트 스위트(unit test suite)가 안정망 역할을 해 줄 때에만 기존 코드를 안전하게 수정할 수 있다.
- 절대로 코드의 작동을 변경하면서 동시에 리팩토링하면 안 된다.
  다시 말해 코드의 작동을 변경하던지, 리팩토링을 하던지 둘 중 하나만 해야지 둘 다 동시에 하려고 하면 안된다. ...

**실천하기 (page 103.)**

- 버그 수정에는 다음 3가지 목표가 있다.
  - 문제 수정
  - 회귀 방지
  - (가독성, 아키텍처, 테스트 커버리지 같은) 전반적인 코드 품질을 유지하거나 향상시키기
- 깨끗한 소스에서 시작한다.
- 코드를 변경하기 전에 먼저 모든 테스트가 통과하는지 확인한다.
- 변경하기 전에 수정된 것을 어떻게 테스트할지 고민한다.
- 증상이 아닌 원인을 고친다.
- 리택토링한다. 하지만 기능을 변경하면서 동시에 하지마라.
- 로직을 하나 바꿀 때마다 체크인한다.

### 문제의 핵심 > 반영

#### **5 Why(page 107.)**

> 근본 원인 분석에 좋은 방법 중 하나가 '왜?'를 다섯 번 묻는 것이다.

예를 들어 다음과 같다.

- 소프트웨어가 크래시됐다. 왜?
  코드에서 데이터 전송 도중에 생긴 네트워크 문제를 제대로 처리하지 못했다. 왜?
- 네트워크 실패를 검사하는 단위 테스트가 없다. 왜?
- 코드를 구현하는 개발자가 그런 테스를 작성해야 한다는 것을 몰랐다. 왜?
- 네트워크 실패를 검사하는 단위 테스트가 하나도 없다. 왜?
- 초기 설계에 네트워크 실패가 고려되지 않았다.

#### **비난(page 108.)**

프로세스 문제를 먼저 나서서 찾아보는 것은 전반적인 품질 향상에 큰 도움이 된다. 하지만 교훈을 얻는게 목적이지 비난하는게 목적이 아니라는 점에 주의하자.

물론 아마도 누군가가 뭔가를 망쳐놓았을 것이다. 하지만 실수는 누구나 한다. 손가락질 해봐야 전혀 생산적이지도 않고, 도움도 안된다.

비난하는 문화는 성공에 꼭 필요한 팀워크를 갉아먹는다. 실수에 대해 공개 비판 당하거나 처벌받는 것을 두려워한다면 팀원들은 팀과, 더 넓게는 조직에 최선을 다하기보다 스스로를 지키는 데 급급하기 시작할 것이다. 최악의 경우 거짓말하고 희생양을 찾는 등의 여러 문제가 생길 수 있다.

모범을 보여 이끄는 방법은 좋은 의도에서든 나쁜 의도에서든 강력하다. 짜증나는 버그의 원인을 찾은 후에 범인에게 큰 소리로 불평하기 시작하면 다른 팀원들도 그대로 따라할 것이다. 하지만 반대로 내가 실수한 문제가 밝혀졌을 때 잘못을 인정하고 '내 탓이요'리고 한다면 사람들에게 버그 때문에 부끄러워 할 거 없다는 점을 몸소 보여줄 수 있다. 문제를 찾은 후에 이를 어떻게 처리할 것인가가 그 문제가 있었다는 사실보다 훨씬 더 중요하다.

### 큰 그림 > 문제의 발견

#### 고객과 협업하기

> 버그 리포트의 소중함

**프로세스 최적화**

- 버그 리포팅 쉽게 만들기
- 자동화: 최상위 예외 처리 루틴을 넣고 여기에서 사용자가 관련 상세 정보가 전부 들어있는 버그 리포트를 보낼 수 있는 옵션 제공
- 여러 옵션 제공: 대면, 비대면(이메일)
- 간단하게 유지하기
- 형식에 너무 집작하지 않기: 버그 리포트에 표준 형식이 있는건 좋다. 히지만 너무 집착하지 않게 주의하자. 입력 사항에 **`모두 해당 안 됨`** 옵션을 추가하는 재치도 잊지 말자.
- 사용자의 개인 정보 존중

**효과적인 의사소통**

...

효과적인의사소통이 되려면 문맥을 공유해야 하지만 개발자의 시점은 사용자의 시점과 다를 수밖에 없다.

...

개발자는 코드를 잘, 고객은 문제 도메인에 대해 더 잘 알고 있다. 이런 차이점을 알고 여기에서 생길수 있는 문제점을 알고 있어야 한다.
이런 의사소통 문제를 해결해줄 쉬운 방법은 없다. 의사소통이 쉽지 않다는 점을 인식하고 평정을 유지하면서 해쳐 나가는 수밖에 없다.

### 디버깅 > 이상적인 디버깅 환경

#### 버젼 달기 (page 190.)

버그 리포트에는 버그 3.6.2 버전에서 발생했다고 한다. 이 정보로 우리는 무엇을 알 수 있을까?
이 정보는 우리가 소스 관리 시스템에 버전을 매겨놔서 해당 버젼을 어떻게 빌드할 수 있는지를 정확하게 알 수 있을 때에만 의미가 있다. 따라서 릴리스를 만들 대마다 어떤 소스로 빌드했는지를 기록해둬야 한다.
버전달기는 소스 시스템에 따라 태그, 브랜치, 레이블이라고 한다. 어떤 방식이든지 버전과 소스가 항상 1:1 관계가 되게 한다. '절대 같은 버전을 재사용하지 않는다'도 굉장히 중요한 규칙이다. 릴리스를 하자마자 치명적인 버그를 발견해 그걸 수정한 릴리스를 또 빌드하더라도 새로운 릴리스용으로 버전을 바꿔준다. 얼마나 조금만 수정하느냐에 상관없이 무조건 버전을 바꿔준다. **소스가 다르면 버전도 달라야 한다.**

### 디버깅 > 소프트웨어가 스스로를 디버깅하게 만들기

#### 자원 누수와 예외 처리 (page 215.)

최선을 다해 문제를 미리 찾아내는 게 제품에서 문제가 발견될 때까지 기다리는 것보다 훨씬 좋다. 이런 사실은 특히 자원 누수나 예외 처리 같은 버그에서 더욱더 그렇다.
이런 문제들은 서로 관계가 있으면서(자원 누수는 예외 처리를 잘못했을 때 자주 발생한다) 조직적이기 마련이다. 한 곳에서 실수를 했다면 분명 같은 실수를 다른 곳에도 했을 가능성이 높다. 증상이 나타날 때까지 기다리고 있다간 엄청난 작업량에 짓눌릴것이다. 그때쯤 되면 코드에 온통 문제가 퍼져 있을 것이기 때문이다.
